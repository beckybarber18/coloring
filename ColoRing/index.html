<html>

    <head>

        <script src='Box2dWeb.min.js'></script>
        <script src="Three.js"></script>
        <script src="keyboard.js"></script>
        <script src="jquery.js"></script>
        <script src="maze.js"></script>
        <script src="js/render_world.js"></script>
        <script src="js/physics_world.js"></script>

        <script>

            var camera         = undefined,
                scene          = undefined,
                renderer       = undefined,
                light          = undefined,
                mouseX         = undefined,
                mouseY         = undefined,
                maze           = undefined,
                mazeMesh       = undefined,
                mazeDimension  = 3,
                mazeWidth      = 0.1;
                planeMesh      = undefined,
                ballMesh       = undefined,
                ballRadius     = 0.1,
                keyAxis        = [0, 0],
                keyAxis2        = [0, 0],
                ironTexture    = THREE.ImageUtils.loadTexture('/ball.png'),
                ironTexture2    = THREE.ImageUtils.loadTexture('/ball2.png'),
                planeTexture   = THREE.ImageUtils.loadTexture('/concrete.png'),
                brickTexture   = THREE.ImageUtils.loadTexture('/brick.png'),
                gameState      = undefined,

            // Box2D shortcuts
                b2World        = Box2D.Dynamics.b2World,
                b2FixtureDef   = Box2D.Dynamics.b2FixtureDef,
                b2BodyDef      = Box2D.Dynamics.b2BodyDef,
                b2Body         = Box2D.Dynamics.b2Body,
                b2CircleShape  = Box2D.Collision.Shapes.b2CircleShape,
                b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
                b2Settings     = Box2D.Common.b2Settings,
                b2Vec2         = Box2D.Common.Math.b2Vec2,

            // Box2D world variables
                wWorld         = undefined,
                wBall          = undefined;

            function generate_maze_mesh(field) {
                var dummy = new THREE.Geometry();
                for (var i = 0; i < mazeDimension; i+=mazeWidth) {
                    for (var j = 0; j < mazeDimension; j+=mazeDimension - mazeWidth) {
                        var geometry = new THREE.CubeGeometry(mazeWidth,mazeWidth,mazeWidth,1,1,1);
                        var mesh_ij = new THREE.Mesh(geometry);
                        mesh_ij.position.x = i;
                        mesh_ij.position.y = j;
                        mesh_ij.position.z = 0.05;
                        THREE.GeometryUtils.merge(dummy, mesh_ij);
                    }
                }
                for (var j = 0; j < mazeDimension; j+=mazeWidth) {
                    for (var i = 0; i < mazeDimension; i+=mazeDimension - mazeWidth) {
                        var geometry = new THREE.CubeGeometry(mazeWidth,mazeWidth,mazeWidth,1,1,1);
                        var mesh_ij = new THREE.Mesh(geometry);
                        mesh_ij.position.x = i;
                        mesh_ij.position.y = j;
                        mesh_ij.position.z = 0.05;
                        THREE.GeometryUtils.merge(dummy, mesh_ij);
                    }
                }
                // var material = new THREE.MeshPhongMaterial({map: brickTexture});
                var mesh = new THREE.Mesh(dummy)
                return mesh;
            }

            function generate_maze_floor() {
              let floor = [];
              for (x = 0; x < mazeDimension; x += 0.05) {
                for (y = 0; y < mazeDimension; y += 0.05) {
                  geo = new THREE.CubeGeometry(0.05, 0.05, 0.005, 1, 1, 1);
                  mat = new THREE.MeshPhongMaterial({color: 0x878e88, shading: THREE.FlatShading});
                  mesh = new THREE.Mesh(geo, mat);
                  mesh.position.x = x;
                  mesh.position.y = y;
                  floor.push(mesh);
                  scene.add(mesh);
                }
              }
              return floor;
            }


            function gameLoop() {

                switch(gameState) {

                    case 'initialize':
                        maze = generateSquareMaze(mazeDimension);
                        maze[mazeDimension-1][mazeDimension-2] = false;
                        createPhysicsWorld();
                        createRenderWorld();
                        camera.position.set(1, 1, 5);
                        light.position.set(1, 1, 1.3);
                        light.intensity = 0;
                        var level = Math.floor((mazeDimension-1)/2 - 4);
                        $('#level').html('Level ' + level);
                        gameState = 'fade in';
                        break;

                    case 'fade in':
                        light.intensity += 0.1 * (1.0 - light.intensity);
                        renderer.render(scene, camera);
                        if (Math.abs(light.intensity - 1.0) < 0.05) {
                            light.intensity = 1.0;
                            gameState = 'play'
                        }
                        break;

                    case 'play':
                        updatePhysicsWorld();
                        updateRenderWorld();
                        renderer.render(scene, camera);

                        // Check for victory.
                        // var mazeX = Math.floor(ballMesh.position.x + 0.5);
                        // var mazeY = Math.floor(ballMesh.position.y + 0.5);
                        // if (mazeX == mazeDimension && mazeY == mazeDimension - 2) {
                        //     mazeDimension += 2;
                        //     gameState = 'fade out';
                        // }
                        break;

                    case 'fade out':
                        updatePhysicsWorld();
                        updateRenderWorld();
                        light.intensity += 0.1 * (0.0 - light.intensity);
                        renderer.render(scene, camera);
                        if (Math.abs(light.intensity - 0.0) < 0.1) {
                            light.intensity = 0.0;
                            renderer.render(scene, camera);
                            gameState = 'initialize'
                        }
                        break;

                }

                requestAnimationFrame(gameLoop);

            }


            function onResize() {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
            }


            function onMoveKey(axis) {
                keyAxis = axis.slice(0);
            }

            function onMoveKey2(axis) {
                keyAxis2 = axis.slice(0);
            }

            jQuery.fn.centerv = function () {
                wh = window.innerHeight;
                h = this.outerHeight();
                this.css("position", "absolute");
                this.css("top", Math.max(0, (wh - h)/2) + "px");
                return this;
            }


            jQuery.fn.centerh = function () {
                ww = window.innerWidth;
                w = this.outerWidth();
                this.css("position", "absolute");
                this.css("left", Math.max(0, (ww - w)/2) + "px");
                return this;
            }


            jQuery.fn.center = function () {
                this.centerv();
                this.centerh();
                return this;
            }


            $(document).ready(function() {

                // Prepare the instructions.
                $('#instructions').center();
                $('#instructions').hide();
                KeyboardJS.bind.key('i', function(){$('#instructions').show()},
                                         function(){$('#instructions').hide()});

                // Create the renderer.
                renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                // Bind keyboard and resize events.
                KeyboardJS.bind.axis('left', 'right', 'down', 'up', onMoveKey);
                KeyboardJS.bind.axis('h', 'l', 'j', 'k', onMoveKey);
                KeyboardJS.bind.axis('a','d','s','w', onMoveKey2)
                $(window).resize(onResize);


                // Set the initial game state.
                gameState = 'initialize';

                // Start the game loop.
                requestAnimationFrame(gameLoop);

            })



        </script>

        <style>

            body {
                background: black;
                margin: 0;
                padding: 0;
                font-family: 'Helvetica';
            }

            #instructions {
                background-color: rgba(0,0,0,0.75);
                color: white;
                text-align: center;
                padding: 32px;
                margin: 0px;
                display: inline;
                border: 2px solid white;
            }

            #help {
                position: absolute;
                left: 0px;
                bottom: 0px;
                padding: 4px;
                color: white;
            }

            /* #level {
                position: absolute;
                left: 0px;
                top: 0px;
                padding: 4px;
                color: yellow;
                font-weight: bold;
            } */

        </style>

    </head>

    <body>

    <div id='instructions'>
        How to play Astray:
        <br><br>
        Use the arrow keys to move the ball and find the exit to the maze.
        <br><br>
        Vim trainees: h, j, k, l
    </div>

    <div id='help'>
        Hold down the 'I' key for instructions.
    </div>

    <div id='level'>
        Level 1
    </div>

    </body>

</html>
